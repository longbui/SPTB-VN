---
title: "Spatial and Temporal Analysis of TB in NAm Dinh Using INLA"
format: html
---

# Introduction

This document outlines the process of analyzing spatial and tedrivemporal data using Integrated Nested Laplace Approximations (INLA) in R. We aim to explore the effects of several predictors on observed outcomes across different spatial and temporal scales.

# Setup

## Load Required Libraries

```{r setup, message=FALSE, warning=FALSE}
library(sf)
library(tidyverse)
library(spdep)
library(INLA)
library(ggthemes)
library(knitr)
```

```{r load_data, message=FALSE, echo=FALSE}
gdf <- st_read("merged_df1.geojson")
colnames(gdf)[colnames(gdf) == "expected"] <- "E"
subset_gdf <- gdf[gdf$year == 2020, ]
nb <- poly2nb(subset_gdf)
nb2INLA("map.adj", nb)

gdf$idarea <- as.numeric(as.factor(gdf$OBJECTID))
gdf$idarea1 <- gdf$idarea
gdf$year = as.integer(gdf$year)
gdf$idtime <- 1 + gdf$year - min(gdf$year)
gdf$idtime1 <-gdf$idtime
g <- inla.read.graph(filename = "map.adj")
gdf <- gdf %>%
  mutate(id2 = row_number())
gdf$idarea.int <- gdf$idarea
gdf$idyear.int <- gdf$idtime
```

```{r}
theme_Publication <- function(base_size=12) {
  library(grid)
  library(ggthemes)
  (theme_foundation(base_size=base_size)
    + theme(plot.title = element_text(face = "bold",
                                      size = rel(1.2), hjust = 0.5),
            text = element_text(),
            panel.background = element_rect(colour = NA),
            plot.background = element_rect(colour = NA),
            panel.border = element_rect(colour="black", fill=NA, linewidth=0.5),
            axis.title = element_text(face = "bold",size = rel(1)),
            axis.title.y = element_text(angle=90,vjust =2),
            axis.title.x = element_text(vjust = -0.2),
            axis.text = element_text(), 
            axis.line = element_line(colour="black"),
            axis.ticks = element_line(),
            panel.grid.major = element_line(colour="#f0f0f0"),
            panel.grid.minor = element_blank(),
            legend.key = element_rect(colour = NA),
            plot.margin=unit(c(10,5,5,5),"mm"),
            strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
            strip.text = element_text(face="bold")
    ))
  
}

scale_fill_Publication <- function(...){
  library(scales)
  discrete_scale("fill","Publication",manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)
  
}

scale_colour_Publication <- function(...){
  library(scales)
  discrete_scale("colour","Publication",manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)
  
}
```

### Calculate TB notifications by time

```{r}
notif_data <- gdf %>%
  group_by(year) %>%
  summarise(
    Total_Observed = sum(observed),
    Total_Population = sum(pop)  # Assuming POP_DENS is total population; change this if it's actually density
  ) %>%
  mutate(notif = (Total_Observed / Total_Population) * 1e5)
```

```{r}
ggplot(notif_data, aes(x = year, y = notif)) +
  geom_line() +
  geom_point() +
  theme_Publication() +
  labs(
    title = "",
    x = "Year",
    y = "TB case notifications per 100,000"
  )
```

### Moran I

```{r}
weights <- poly2nb(subset_gdf, queen = TRUE)  
weights <- nb2listw(weights, style = "W", zero.policy = TRUE)
```

```{r}
# Unique years from the dataset
unique_years <- unique(gdf$year)

# Initialize an empty list to store results
moran_results <- list()

# Loop through each year and calculate Moran's I
for (current_year in unique_years) {
  # Subset data for the specific year
  year_data <- dplyr::filter(gdf, year == current_year)

  # Check if year_data is empty after subsetting
  if (nrow(year_data) == 0) {
    cat(sprintf("Moran's I for year %d: No data for this year\n", current_year))
    moran_results[[as.character(current_year)]] <- list(year = current_year, moran = NA, p_value = NA, warning = "No data for this year")
    next
  }

  # Convert 'SMR' to numeric
  year_data$SMR <- as.numeric(as.character(year_data$SMR))

  # Check for NA values
  if (any(is.na(year_data$SMR))) {
    cat(sprintf("Moran's I for year %d: NA values present in SMR data\n", current_year))
    moran_results[[as.character(current_year)]] <- list(year = current_year, moran = NA, p_value = NA, warning = "NA values present in SMR data")
    next
  }

  # Ensure the order of SMR values matches the spatial units in the weights matrix
  if (length(year_data$SMR) != length(weights$neighbours)) {
    cat(sprintf("Moran's I for year %d: Mismatch in data length and weights matrix\n", current_year))
    moran_results[[as.character(current_year)]] <- list(year = current_year, moran = NA, p_value = NA, warning = "Mismatch in data length and weights matrix")
    next
  }

  # Perform Moran's I test
  moran_test <- moran.test(year_data$SMR, weights, zero.policy = TRUE)
  #cat(sprintf("Moran's I for year %d is %f with a normal p-value of %f\n", current_year, moran_test$estimate, moran_test$p.value))
  
  # Store results in the list
  moran_results[[as.character(current_year)]] <- list(year = current_year, moran = moran_test$estimate, p_value = moran_test$p.value)
}

# Optionally print all results at the end
#print(moran_results)

```

```{r moran, warning=FALSE}


# Assuming moran_results is a list of lists with each year's result
# Convert the list to a data frame
results_df <- do.call(rbind, lapply(names(moran_results), function(year) {
  moran <- moran_results[[year]]$moran
  data.frame(
    Year = as.integer(year),
    Moran_I = moran[1],   # Moran I statistic
    Expectation = moran[2],  # Expected value
    Variance = moran[3],  # Variance of Moran's I
    P_Value = moran_results[[year]]$p_value
  )
}))

# Convert P_Value to factor with labels for significance
results_df$Significance <- cut(results_df$P_Value,
                               breaks = c(-Inf, 0.05, 0.01, 0.001, Inf),
                               labels = c("> 0.05", "0.05", "0.01", "0.001"),
                               right = FALSE)

### 2. Presenting the Data

# Use kable from knitr to create a nice table
knitr::kable(results_df, format = "html", table.attr = "style='width:100%;'", 
             col.names = c("Year", "Moran I", "Expectation", "Variance", "P-Value", "Significance"))

```

```{r}
gdf$year = as.integer(gdf$year)
data1 <- gdf %>%
  group_by(year) %>%
  do({
    .data <- .
    local_moran_results <- localmoran(.data$SMR, weights)
    # Transform results into a dataframe to rejoin with original data
    data.frame(.data, 
               local_I = local_moran_results[, "Ii"],
               p_value = 2 * pnorm(-abs(local_moran_results[, "Z.Ii"]), lower.tail = TRUE),  # two-sided p-value
               hotspot_type = attr(local_moran_results, "quadr")[["pysal"]]  # assuming 'pysal' gives the most consistent results
    )
  }) %>%
  ungroup()
```

```{r}
# Visualization using ggplot2 with facets for each year
merged_data <- gdf %>%
  # Step 1: Remove the 'observed' column from gdf before merging
  select(-observed, -hotspot_type) %>%
  # Step 2: Merge with selected columns from data1
  left_join(data1 %>%
            select(OBJECTID, year, observed, SMR, hotspot_type),
            by = c("OBJECTID", "year"))

```

```{r}
merged_data$hotspot_type <- factor(merged_data$hotspot_type, 
                                   levels = c("High-High", "High-Low", "Low-High", "Low-Low", "Not significant"))

lisa_plot <- ggplot(data = merged_data) +
  geom_sf(aes(fill = hotspot_type), color = "black") +  # Fill regions based on hotspot type and set borders to black
  scale_fill_manual(values = c("High-High" = "red", "Low-Low" = "blue",
                               "High-Low" = "pink", "Low-High" = "green",
                               "Not significant" = "grey")) +  # Define manual color for each hotspot type
  facet_wrap(~ year, ncol = 2) +  # Facet by 'year', with two columns
  labs(title = "",
       fill = "Hotspot Type") +
 theme_Publication() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.border = element_blank(), axis.line = element_blank(),
        strip.background = element_blank(),  # Remove facet label backgrounds
        strip.text = element_text(color = "black", size = 12),  # Style facet labels
        axis.text.x = element_blank(),  # Remove x-axis labels
        axis.text.y = element_blank(),  # Remove y-axis labels
        axis.ticks = element_blank(),  # Remove axis ticks
        legend.title = element_blank(),
        legend.position = "right",  # Set legend position to top right
        legend.justification = "top",
        legend.text = element_text(size = 8),  # Smaller legend text
        legend.key.size = unit(0.5, "cm"),
        plot.margin = grid::unit(c(0,0,0,0), "mm"))  # Justify the 

```

```{r}
merged_data <- merged_data %>%
  mutate(
    observed_category = cut(observed,
                            breaks = c(0, 5, 10, Inf),
                            labels = c("1-5", "6-10", "11+"),
                            right = TRUE)  # intervals are closed on the right
  )

# Create a spatial plot with faceting by year, arranged in two columns
oplot <- ggplot(data = merged_data) +
  geom_sf(aes(fill = observed_category), color = "black") +  # Fill regions based on observed category
  scale_fill_manual(values = c("1-5" = "blue", "6-10" = "orange", "11+" = "red"),  # Custom colors
                    name = "Observed Cases",  # Rename legend title
                    guide = guide_legend(title.position = "top")) +
  facet_wrap(~ year, ncol = 2) +  # Facet by 'year', with two columns
  labs(title = "") +
  theme_Publication() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), panel.border = element_blank(), axis.line = element_blank(),
        strip.background = element_blank(),  # Remove facet label backgrounds
        strip.text = element_text(color = "black", size = 12),  # Style facet labels
        axis.text.x = element_blank(),  # Remove x-axis labels
        axis.text.y = element_blank(),  # Remove y-axis labels
        axis.ticks = element_blank(),  # Remove axis ticks
        legend.title = element_blank(),
        legend.position = "right",  # Set legend position to top right
        legend.justification = "top",
        legend.text = element_text(size = 8),  # Smaller legend text
        legend.key.size = unit(0.5, "cm"),
        plot.margin = grid::unit(c(0,0,0,0), "mm"))  # Justify the 
```

# Model fitting

## Spatial convolution model (1a)

```{r}
formula1<-observed~1+f(idarea,model="iid")+f(idarea1, model="besag",graph=g)
result1<-inla(formula1,family="poisson",data=gdf,
              E=E,control.predictor = list(compute = TRUE),
              control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result1)
```

```{r}
formula1a<-observed~1+f(idarea1, model="bym",graph=g)
result1a<-inla(formula1a,family="poisson",data=gdf,
              E=E,control.predictor = list(compute = TRUE),
              control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result1a)
```

## Spatial convolution model with covariates (model 1b)

```{r}
formula1b<-observed~1+f(idarea1,model="bym",graph=g) + poor + POP_DENS
result1b<-inla(formula1b,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result1b)
```

## Spatial convolution + time trend (2a)

```{r}
formula2<-observed~1+f(idarea1,model="bym",graph=g)+idtime
result2<-inla(formula2,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result2)
```

## Spatial convolution + time trend + cov (2b)

```{r}
formula2b<-observed~1+f(idarea1,model="bym",graph=g)+idtime + poor + POP_DENS
result2b<-inla(formula2b,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result2b)
```

## Spatial convolution + temporal random walk 1 (3a)

```{r}
formula3<-observed~1+f(idarea1, model="bym",graph=g) + f(idtime,model="rw1")
result3<-inla(formula3,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result3)
```

## Spatial convolution + temporal random walk 1 + cov (3b)

```{r}
formula3b<-observed~1+f(idarea1, model="bym",graph=g) + f(idtime,model="rw1") + poor + POP_DENS
result3b<-inla(formula3b,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result3b)
```

### Bernadinielli (4a)

```{r}
 formula4 <- observed ~ f(idarea, model = "bym", graph = g) +
  f(idarea1, idtime, model = "iid") + idtime
result4 <- inla(formula4,
            family = "poisson", data = gdf, E = E,
            control.predictor = list(compute = TRUE),
            control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE)
)
summary(result4)
```

## Bernaderlli with covariates (poor and pop dens)

```{r}
formula4b <- observed ~ f(idarea, model = "bym", graph = g) +
  f(idarea1, idtime, model = "iid") + idtime + poor + POP_DENS
result4b <- inla(formula4b,
            family = "poisson", data = gdf, E = E,
            control.predictor = list(compute = TRUE),
            control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE, return.marginals.predictor=TRUE)
)
summary(result4b)
```

## Spatial convolution + temporal random walk + idd space-time interaction

```{r}
formula5<-observed~1+f(idarea1,model="bym",graph=g)+ f(idtime,model="rw1")+f(id2,model="iid")
result5<-inla(formula5,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result5)
```

## Spatial convolution + temporal random walk + idd space-time interaction + cov

```{r}
formula5b<-observed~1+f(idarea1,model="bym",graph=g)+ f(idtime,model="rw1")+f(id2,model="iid") + poor + POP_DENS
result5b<-inla(formula5b,family="poisson",data=gdf,
              E=E,control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE))
summary(result5b)
```

### Analyzing M4b - best fitted

```{r}
result4b$summary.fixed
```

```{r}
result4b$summary.hyperpar
```

## Sensitivity analysis

```{r}
formula4b_p3 <- observed ~ f(idarea, model = "bym", graph = g) +
  f(idarea1, idtime, model = "iid", param=c(0.1, 0.5)) + idtime + poor + POP_DENS
result4b_p3 <- inla(formula4b_p3,
            family = "poisson", data = gdf, E = expected,
            control.predictor = list(compute = TRUE),
            control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE, return.marginals.predictor=TRUE)
)
summary(result4b_p3)

```

```{r}
formula4b_bym_iid <- observed ~ f(idarea, model = "bym", graph = g, hyper = list( prec.spatial = list(prior = "loggamma", param = c(0.01, 0.01)), prec.unstruct = list(prior = "loggamma", param = c(0.01, 0.01)) )) + f(idarea1, idtime, model = "iid", hyper = list( prec = list(prior = "loggamma", param = c(0.01, 0.01)) )) + idtime + poor + POP_DENS
result4b_bym_idd <- inla(formula4b_bym_iid, family = "poisson", data = gdf, E = E, control.predictor = list(compute = TRUE), control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE, return.marginals.predictor=TRUE) ) 
summary(result4b_bym_idd)
```

```{r}
formula4b_l <- observed ~ f(idarea, model = "bym",hyper = list( prec.spatial = list(prior = "loggamma", param = c(2, 0.05)), prec.unstruct = list(prior = "loggamma", param = c(2, 0.5)) ), graph = g) + f(idarea1, idtime, model = "iid", hyper = list( prec = list(prior = "loggamma", param = c(2, 0.5)) )) + idtime + poor + POP_DENS

result4b_l <- inla(formula4b_l, family = "poisson", data=gdf, E=E, control.predictor = list(compute = TRUE), control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE, return.marginals.predictor=TRUE))
summary(result4b_l)
```

```{r}
formula4b_l3 <- observed ~ f(idarea, model = "bym",hyper = list( prec.spatial = list(prior = "loggamma", param = c(1, 0.0001)), prec.unstruct = list(prior = "loggamma", param = c(1, 0.0001)) ), graph = g) + f(idarea1, idtime, model = "iid", hyper = list( prec = list(prior = "loggamma", param = c(1, 0.0001)) )) + idtime + poor + POP_DENS
result4b_l3 <- inla(formula4b_l3, family = "poisson", data = gdf, E = E, control.predictor = list(compute = TRUE), control.compute=list(dic=TRUE,cpo=TRUE,waic=TRUE, return.marginals.predictor=TRUE))
summary(result4b_l3)
```

## Plot id time effect:

```{r}
# Create a more granular sequence for x
x_fine <- seq(from = 1, to = 10, by = 0.1)
years_fine <- seq(from = 2013, to = 2022, length.out = length(x_fine))

# Compute interpolated model estimates
beta_main <- result4b_bym_idd$summary.fixed[2,1]
beta_lower <- result4b_bym_idd$summary.fixed[2,3]
beta_upper <- result4b_bym_idd$summary.fixed[2,5]

df_fine <- data.frame(
  Year = years_fine,
  Main = beta_main * x_fine,
  Lower = beta_lower * x_fine,
  Upper = beta_upper * x_fine
)

# Melting data frame for easier plotting with ggplot2
df_long_fine <- tidyr::pivot_longer(df_fine, cols = c("Main", "Lower", "Upper"), names_to = "LineType", values_to = "Value")

# Plotting
time_eff_fine <- ggplot(df_long_fine, aes(x = Year, y = Value, group = LineType, color = LineType)) +
  geom_line(aes(linetype = LineType)) +  # Add lines with different types
  scale_linetype_manual(values = c("Main" = "solid", "Lower" = "dashed", "Upper" = "dashed")) +  # Customize line types
  scale_color_manual(values = c("Main" = "black", "Lower" = "red", "Upper" = "blue")) +  # Customize line colors if needed
  labs(x = "", y = "", title = "") +  # Add labels
  theme_Publication() +  # Apply the publication theme
  theme(
    legend.title = element_blank(),  # Remove legend title
    legend.position = "none"  # Remove legend if not needed
  ) + 
  scale_x_continuous(breaks = seq(2013, 2022, by = 1), labels = as.character(seq(2013, 2022, by = 1)))
time_eff_fine

```

## Marginal posterior dis

```{r}
plot_combined_marginal_effects_with_quantiles <- function(result_list, effect_name, model_names) {
  # Create an empty data frame to store combined data
  combined_data <- data.frame(x = numeric(), y = numeric(), Model = factor(), lquant = numeric(), uquant = numeric())
  
  # Loop through the list of model results
  for (i in seq_along(result_list)) {
    # Extract the marginal effects for the specified variable
    effect <- result_list[[i]]$marginals.fixed[[effect_name]]
    
    # Calculate the quantiles for the shading
    lquant <- inla.qmarginal(0.025, effect)
    uquant <- inla.qmarginal(0.975, effect)
    
    # Create a data frame from the smoothed marginal
    df_effect <- data.frame(inla.smarginal(effect))
    df_effect$Model <- model_names[i]
    df_effect$lquant <- lquant
    df_effect$uquant <- uquant
    
    # Combine with the main data frame
    combined_data <- rbind(combined_data, df_effect)
  }
  
  # Ensure the 'Model' factor is ordered as desired for the legend
  combined_data$Model <- factor(combined_data$Model, levels = model_names)
  
  # Define line types and widths for better differentiation
  line_types <- c("solid", "dashed", "dotdash", "longdash")
  
  # Generate the plot
  p <- ggplot(combined_data, aes(x, y, color = Model)) +
    geom_line(aes(linetype = Model), size = 1.0) +
    geom_vline(xintercept = 0, linetype = "dashed") +
     scale_colour_manual(values = c("#386cb0", "#fdb462", "#7fc97f")) +
    scale_linetype_manual(values = line_types) +
    theme_Publication(base_size = 12) +
    theme(legend.position = "bottom", legend.title = element_blank(), legend.text = element_text(size = 8)) +
    labs(title = "",
         x = NULL, y = "Probability density")
  
  return(p)
}

# Usage
result_list <- list(result4b, result4b_bym_idd, result4b_l)
model_names <- c("Default priors, log-gamma (1, 0.0005)", "Best-fitted, log-gamma (0.01, 0.01)", "log-gamma (2, 0.5)")
plot <- plot_combined_marginal_effects_with_quantiles(result_list, "poor", model_names)
print(plot)
```
